



Web Authorization Protocol                                     Y. Zehavi
Internet-Draft                             Raiffeisen Bank International
Intended status: Standards Track                              A. Parecki
Expires: 25 June 2026                                               Okta
                                                        22 December 2025


    OAuth 2.0 direct interation for native clients using federation
draft-zehavi-oauth-native-clients-direct-interation-with-federation-latest

Abstract

   [I-D.ietf-oauth-first-party-apps] defined native OAuth 2.0 *direct
   interaction*, whereby clients call the _Native Authorization
   Endpoint_ as an HTTP REST API, obtaining instructions from
   authorization servers on information to collect from users to comply
   with authentication requirements.

   While FiPA [I-D.ietf-oauth-first-party-apps] focused on a one-to-one
   relationship between client and authorization server, this document
   acts as its *extension* adding support for authorization servers to
   federate the interaction to a downstream authorization server,
   instruct the usage of a native app for user interaction, and instruct
   collection of additional information from users needed to guide
   request routing.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://yaron-
   zehavi.github.io/oauth-native-clients-direct-interation-with-
   federation/draft-zehavi-oauth-native-clients-direct-interation-with-
   federation.html.  Status information for this document may be found
   at https://datatracker.ietf.org/doc/draft-zehavi-oauth-native-
   clients-direct-interation-with-federation/.

   Discussion of this document takes place on the Web Authorization
   Protocol Working Group mailing list (mailto:oauth@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/oauth/.
   Subscribe at https://www.ietf.org/mailman/listinfo/oauth/.

   Source for this draft and an issue tracker can be found at
   https://github.com/yaron-zehavi/oauth-native-clients-direct-
   interation-with-federation.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 25 June 2026.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Protocol Overview
     3.1.  Example flow: Native client federated and redirected to app
   4.  Protocol Endpoints
     4.1.  Native Authorization Endpoint
     4.2.  Token endpoint
   5.  Authorization Initiation
     5.1.  Native Authorization Request
     5.2.  Native Authorization Response
       5.2.1.  Authorization Code Response
       5.2.2.  Error Response
     5.3.  Intermediate Requests
       5.3.1.  Auth Session
   6.  Token Request
     6.1.  Token Endpoint Successful Response
     6.2.  Token Endpoint Error Response
   7.  Resource Server Error Response
   8.  Authorization Server Metadata
   9.  Security Considerations
     9.1.  First-Party Applications
     9.2.  Phishing
     9.3.  Credential Stuffing Attacks
     9.4.  Sender-Constrained Tokens
       9.4.1.  DPoP: Demonstrating Proof-of-Possession
       9.4.2.  Other Proof of Possession Mechanisms
     9.5.  Auth Session
       9.5.1.  Auth Session DPoP Binding
       9.5.2.  Auth Session Lifetime
     9.6.  Multiple Applications
       9.6.1.  User Experience Risk
       9.6.2.  Technical Risk
       9.6.3.  Mitigation
     9.7.  Single Page Applications
   10. IANA Considerations
     10.1.  OAuth Parameters Registration
     10.2.  OAuth Server Metadata Registration
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Appendix A.  Example User Experiences
     A.1.  Passkey
     A.2.  Redirect to Authorization Server
     A.3.  Native client federated and redirected to app
       A.3.1.  Diagram
       A.3.2.  Client makes initial request and receives "federate"
               error
       A.3.3.  Client calls federated authorization server and is
               redirected to app
       A.3.4.  Client calls federating authorization server
     A.4.  Passwordless One-Time Password (OTP)
     A.5.  E-Mail Confirmation Code
     A.6.  Mobile Confirmation Code
     A.7.  Re-authenticating to an app a week later using OTP
     A.8.  Step-up Authentication using Confirmation SMS
     A.9.  Registration
   Appendix B.  Example Implementations
     B.1.  Authorization Challenge Request Parameters
     B.2.  Authorization Challenge Response Parameters
     B.3.  Example Sequence
     B.4.  Usage with Digital Credentials
       B.4.1.  RAR & Transaction Data
   Appendix C.  Design Goals
   Appendix D.  Document History
   Acknowledgments
   Authors' Addresses

1.  Introduction

   This document, OAuth 2.0 direct interation for native clients using
   federation, extends FiPA [I-D.ietf-oauth-first-party-apps] to enable
   federation based flows, while retaining client's direct interaction
   with end-user.  The client calls the _Native Authorization Endpoint_
   as an HTTP REST API, and receives instructions as error responses, in
   line with the protocol established by FiPA, guiding client to call
   downstream authorization servers and providing their responses to
   federating authorization servers.  This establishes a multi
   authorization server federated flow, whose user interactions are
   driven by the client app.

   This document extends FiPA [I-D.ietf-oauth-first-party-apps] with new
   error responses: federate, redirect_to_app, insufficient_information
   and native_authorization_federate_unsupported.

   It also adds additional response parameters: federation_uri,
   federation_body, response_uri, deep_link.

   And the native_callback_uri request parameter.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Protocol Overview

   There are three primary ways this specification extends FiPA:

   *  federate response: Sends the client to interact with a downstream
      authorization server.

   *  insufficient_information response: Instructs the client to collect
      information from end-user required to decide where to federate to.
      For example this could be an email address which identifies the
      trust domain.

   *  redirect_to_app: Instructs the client to natively invoke an app to
      interact with end user.

3.1.  Example flow: Native client federated and redirected to app

                                                  +--------------------+
                                                  |   Authorization    |
                            (B)Native             |      Server 1      |
               +----------+ Authorization Request |+------------------+|
  (A)User  +---|          |---------------------->||     Native       ||
     Starts|   |          |                       ||  Authorization   ||
     Flow  +-->|  Client  |<----------------------||    Endpoint      ||
               |          | (C)Federate Error     |+------------------+|
               |          |        Response       +--------------------+
               |          |         :
               |          |         :             +--------------------+
               |          |         :             |   Authorization    |
               |          | (D)Native             |      Server 2      |
               |          | Authorization Request |+------------------+|
               |          |---------------------->||     Native       ||
               |          |                       ||  Authorization   ||
               |          |<----------------------||    Endpoint      ||
               |          | (E) Redirect to       |+------------------+|
               |          |     App Response      +--------------------+
               |          |         :
               |          |         :             +--------------------+
               |          | (F) Invoke App        |                    |
               |          |---------------------->|   Native App of    |
               |          |                       |   Auth Server 2    |
               |          |<----------------------|                    |
               |          | (G)Authorization code +--------------------+
               |          |   For Auth Server 1
               |          |         :             +--------------------+
               |          |         :             |   Authorization    |
               |          | (H)Authorization Code |      Server 1      |
               |          |    For Auth Server 1  |+------------------+|
               |          |---------------------->||    Response      ||
               |          |                       ||       Uri        ||
               |          |<----------------------||    Endpoint      ||
               |          | (I) Authorization     |+------------------+|
               |          |     Code Response     |                    |
               |          |         :             |                    |
               |          |         :             |                    |
               |          | (J) Token Request     |+------------------+|
               |          |---------------------->||      Token       ||
               |          |                       ||     Endpoint     ||
               |          |<----------------------||                  ||
               |          | (K) Access Token      |+------------------+|
               |          |                       +--------------------+
               |          |
               +----------+

   Figure: Native client federated, then redirected to app

   *  (A) The client starts the flow.

   *  (B) The client initiates the authorization request by making a
      POST request to the Native Authorization Endpoint of Authorization
      Server 1.

   *  (C) Authorization Server 1 decides to federate the user to
      Authorization Server 2.  To do so it contacts Authorization Server
      2's PAR [RFC9126] endpoint, then returns the federate error code
      together with the _federation_uri_, _federation_body_,
      _response_uri_ and _auth_session_ response attributes.

   *  (D) The client calls Authorization Server 2's Native Authorization
      Endpoint, as instructed by Authorization Server 1.

   *  (E) Authorization Server 2 decides to use a native app, and
      therefore responds with the redirect_to_app error code together
      with the _deep_link_ response attribute.

   *  (F) The client invokes the app using the deep_link.

   *  (G) The app interacts with user and if satisifed, returns an
      authorization code, regarded as Authorization Server 2's response
      to Authorization Server 1's federation to it.

   *  (H) The client provides the authorization code to Authorization
      Server 1.

   *  (I) Authorization Server 1 returns an authorization code.

   *  (J) The client sends the authorization code received in step (I)
      to obtain a token from the Token Endpoint.

   *  (K) Authorization Server 1 returns an Access Token from the Token
      Endpoint.

4.  Protocol Endpoints

4.1.  Native Authorization Endpoint

   The native authorization endpoint defined by FiPA
   [I-D.ietf-oauth-first-party-apps] is used by this document.

   This document adds the _native_callback_uri_ parameter to the native
   authorization endpoint, to support cross-app native user navigation.

   Before authorization servers instruct a client to federate to a
   downstream authorization server, they MUST ensure it offers a
   _native_authorization_endpoint_, otherwise return the error
   native_authorization_federate_unsupported*.

   When federating to downstream authorization servers, the usage of PAR
   [RFC9126] with client authentication is REQUIRED, as the native
   client calling the Native Authorization Endpoint of a federated
   authorization server is not _its_ OAuth client and therefore has no
   other means of authenticating.  When using PAR with client
   authentication, the request_uri provided to the Native Authorization
   Endpoint attests that client authentication took place.

4.2.  Token endpoint

   The token endpoint is used by the client to obtain an access token by
   presenting its authorization grant or refresh token, as described in
   Section 3.2 of OAuth 2.0 [RFC6749].

   This specification extends the token endpoint response to allow the
   authorization server to indicate that further authentication of the
   user is required.

5.  Authorization Initiation

   A client may wish to initiate an authorization flow by first
   prompting the user for their user identifier or other account
   information.  The native authorization endpoint is a new endpoint to
   collect this login hint and direct the client with the next steps,
   whether that is to do an MFA flow, or perform an OAuth redirect-based
   flow.

   In order to preserve the security of this specification, the
   Authorization Server MUST verify the "first-partyness" of the client
   before continuing with the authentication flow.  Please see
   Section 9.1 for additional considerations.

5.1.  Native Authorization Request

   The client makes a request to the native authorization endpoint by
   adding the following parameters, as well as parameters from any
   extensions, using the application/x-www-form-urlencoded format with a
   character encoding of UTF-8 in the HTTP request body:

   "client_id":  REQUIRED if the client is not authenticating with the
      authorization server and if no auth_session is included.

   "scope":  OPTIONAL.  The OAuth scope defined in [RFC6749].

   "auth_session":  OPTIONAL.  If the client has previously obtained an
      auth session, described in Section 5.3.1.

   "code_challenge":  OPTIONAL.  The code challenge as defined by
      [RFC7636].  See Section 5.2.2.4 for details.

   "code_challenge_method":  OPTIONAL.  The code challenge method as
      defined by [RFC7636].  See Section 5.2.2.4 for details.

   "native_callback_uri":  OPTIONAL.  Native client app's
      *redirect_uri*, claimed as deep link. _native_callback_uri_ SHALL
      be natively invoked by authorization server's user-interacting app
      to provide its response to the client app.  If native_callback_uri
      is included in a native authorization request, authorization
      server MUST include the native_callback_uri when federating to
      another authorization server.

   Specific implementations as well as extensions to this specification
   MAY define additional parameters to be used at this endpoint.

   For example, the client makes the following request to initiate a
   flow given the user's phone number, line breaks shown for
   illustration purposes only:

   POST /native-authorization HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   login_hint=%2B1-310-123-4567&scope=profile
   &client_id=bb16c14c73415

5.2.  Native Authorization Response

   The authorization server determines whether the information provided
   up to this point is sufficient to issue an authorization code, and if
   so responds with an authorization code.  If the information is not
   sufficient for issuing an authorization code, then the authorization
   server MUST respond with an error response.

5.2.1.  Authorization Code Response

   The authorization server issues an authorization code by creating an
   HTTP response content using the application/json media type as
   defined by [RFC8259] with the following parameters and an HTTP 200
   (OK) status code:

   "authorization_code":  REQUIRED.  The authorization code issued by
      the authorization server.

   For example,

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "authorization_code": "uY29tL2F1dGhlbnRpY"
   }

5.2.2.  Error Response

   If the request contains invalid parameters or incorrect data, or if
   the authorization server wishes to interact with the user directly,
   the authorization server responds with an HTTP 400 (Bad Request)
   status code (unless specified otherwise below) and includes the
   following parameters with the response:

   "error":  REQUIRED.  A single ASCII [USASCII] error code from the
      following:

      "invalid_request":  The request is missing a required parameter,
         includes an unsupported parameter value, repeats a parameter,
         includes multiple credentials, utilizes more than one mechanism
         for authenticating the client, or is otherwise malformed.

      "invalid_client":  Client authentication failed (e.g., unknown
         client, no client authentication included, or unsupported
         authentication method).  The authorization server MAY return an
         HTTP 401 (Unauthorized) status code to indicate which HTTP
         authentication schemes are supported.  If the client attempted
         to authenticate via the Authorization request header field, the
         authorization server MUST respond with an HTTP 401
         (Unauthorized) status code and include the WWW-Authenticate
         response header field matching the authentication scheme used
         by the client.

      "unauthorized_client":  The authenticated client is not authorized
         to use this endpoint.

      "invalid_session":  The provided auth_session is invalid, expired,
         revoked, or is otherwise invalid.

      "invalid_scope":  The requested scope is invalid, unknown,
         malformed, or exceeds the scope granted by the resource owner.

      "insufficient_authorization":  The presented authorization is
         insufficient, and the authorization server is requesting the
         client take additional steps to complete the authorization.

      "insufficient_information":  the Authorization Server requires
         additional user input, other than an authentication challenge,
         to determine the target authorization server to federate to.
         See Section 5.2.2.3 for details.

      "federate":  The Authorization Server wishes to federate to
         another authorization server, which it is a client of.  This
         response MUST include the _federation_uri_ response parameter.
         See Section 5.2.2.1 for details.

      "redirect_to_app":  The Authorization Server wishes to fulfill the
         user interaction using another native app.  This response MUST
         include the _federation_uri_ response parameter.  See
         Section 5.2.2.2 for details.

      "redirect_to_web":  The request is not able to be fulfilled with
         any further direct interaction with the user.  Instead, the
         client should initiate a new authorization code flow so that
         the user interacts with the authorization server in a web
         browser.  See Section 5.2.2.4 for details.

      "native_authorization_federate_unsupported":  The authorization
         server intended to federate to a downstream authorization
         server, but it does not support the native authorization
         endpoint.

      Values for the error parameter MUST NOT include characters outside
      the set %x20-21 / %x23-5B / %x5D-7E.

      The authorization server MAY extend these error codes with custom
      messages based on the requirements of the authorization server.

   "error_description":  OPTIONAL.  Human-readable ASCII [USASCII] text
      providing additional information, used to assist the client
      developer in understanding the error that occurred.  Values for
      the error_description parameter MUST NOT include characters
      outside the set %x20-21 / %x23-5B / %x5D-7E.

   "error_uri":  OPTIONAL.  A URI identifying a human-readable web page
      with information about the error, used to provide the client
      developer with additional information about the error.  Values for
      the error_uri parameter MUST conform to the URI-reference syntax
      and thus MUST NOT include characters outside the set %x21 /
      %x23-5B / %x5D-7E.

   "auth_session":  OPTIONAL.  The auth session allows the authorization
      server to associate subsequent requests by this client with an
      ongoing authorization request sequence.  The client MUST include
      the auth_session in follow-up requests to the native authorization
      endpoint if it receives one along with the error response.

   "request_uri":  OPTIONAL.  A request URI as described by [RFC9126]
      Section 2.2.

   "federation_uri":  OPTIONAL.  The Native Authorization Endpoint of a
      downstream authorization server to federate to.

   "deep_link":  OPTIONAL.  A URI of native app to be invoked to handle
      the request.

   "federation_body":  OPTIONAL.  A string of application/x-www-form-
      urlencoded request parameters according to this specification for
      the downstream authorization server's Native Authorization
      Endpoint.

   "response_uri":  OPTIONAL.  A URI of an endpoint of federating
      authorization server which shall receive the response from the
      federated authorization server.

   "expires_in":  OPTIONAL.  The lifetime of the request_uri in seconds,
      as described by [RFC9126] Section 2.2.

   This specification requires the authorization server to define new
   error codes that relate to the actions the client must take in order
   to properly authenticate the user.  These new error codes are
   specific to the authorization server's implementation of this
   specification and are intentionally left out of scope.

   The parameters are included in the content of the HTTP response using
   the application/json media type as defined by [RFC7159].  The
   parameters are serialized into a JSON structure by adding each
   parameter at the highest structure level.  Parameter names and string
   values are included as JSON strings.  Numerical values are included
   as JSON numbers.  The order of parameters does not matter and can
   vary.

   The authorization server MAY define additional parameters in the
   response depending on the implementation.  The authorization server
   MAY also define more specific content types for the error responses
   as long as the response is JSON and conforms to application/<AS-
   defined>+json.

5.2.2.1.  Federating Response

   If the authorization server decides to federate to another
   authorization server, it responds with error code _federate_ and MUST
   return the _federation_uri_, _federation_body_, _response_uri_ and
   _auth_session_ response attributes.

   When federating to another authorization server: * Federating
   authorization server MUST use PAR [RFC9126] and include _request_uri_
   in federation_body. * If _native_callback_uri_ was included in the
   native authorization request, it MUST be included when calling
   federated authorization server's Native Authorization Endpoint.

   Example *federating* response:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "federate",
       "auth_session": "ce6772f5e07bc8361572f",
       "response_uri": "https://prev-as.com/native-authorization",
       "federation_uri": "https://next-as.com/native-authorization",
       "federation_body": "client_id=s6BhdRkqt3&request_uri=
         urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX"
   }

   Client MUST call the _federation_uri_ using HTTP POST, and provide it
   _federation_body_ as application/x-www-form-urlencoded request body.
   Example:

   POST /native-authorization HTTP/1.1
   Host: next-as.com
   Content-Type: application/x-www-form-urlencoded

   client_id=s6BhdRkqt3&request_uri=
   urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX

   The federated authorization server should consider end-user's privacy
   and security to determine if it should present authorization
   challenges in federation scenarios.  For example, it can label
   *federating* clients as such and avoid serving them authorization
   challenges, as user-serving clients receiving those challenges are
   not first party clients.

   The client MUST provide any response obtained from the *federated*
   authorization server, as application/x-www-form-urlencoded request
   body for the _response_uri_ of the respective *federating*
   authorization server which SHALL be invoked using HTTP POST.

   However, when *federated* authorization server returns the following
   error codes: _federate_, _insufficient_authorization_,
   _insufficient_information_, _redirect_to_app_, _redirect_to_web_,
   client MUST handle these errors according to this specification.

   Example client calling receiving an authorization code response
   Section 5.2.1 from the federated authorization server:

   HTTP/1.1 200 OK
   Server: next-as.com
   Content-Type: application/json
   Cache-Control: no-store

   {
     "authorization_code": "uY29tL2F1dGhlbnRpY"
   }

   And providing it to the federating authorization server's
   response_uri, adding previously obtained auth_session:

   POST /native-authorization HTTP/1.1
   Host: prev-as.com
   Content-Type: application/x-www-form-urlencoded

   authorization_code=uY29tL2F1dGhlbnRpY
   &auth_session=ce6772f5e07bc8361572f

5.2.2.2.  Redirect to app response

   If the authorization server decides to use a native app to interact
   with end user, it responds with error code _redirect_to_app_ and MUST
   return the _deep_link_ response attribute.

   Example *redirect_to_app* response:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "redirect_to_app",
       "deep_link": "https://next-as.com/native-authorization?
         client_id=s6BhdRkqt3&request_uri=
         urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX"
   }

   Client MUST use OS mechanisms to invoke the obtained deep_link.  If
   no app claiming deep_link is found on the device, client MUST
   terminate the flow and MAY attempt a normal non-native OAuth flow.

   The invoked app handles the native authorization request:

   *  Validates the request and ensures it contains a
      _native_callback_uri_, Otherwise terminates the flow.

   *  Establishes trust in _native_callback_uri_ and validates that an
      app claiming it is on the device.  Otherwise terminates the flow.

   *  Authenticates end-user and authorizes the request.

   *  Uses OS mechanisms to natively invoke _native_callback_uri_ and
      return to the client, providing it a response according to this
      specification's response from a Native Authorization Endpoint, as
      url-encoded query parameters.

   Note - trust establishment mechanisms in _native_callback_uri_ are
   out of scope of this specification.  However we assume closed
   ecosystems could employ an allowList, and open ecosystems could
   leverage [OpenID.Federation]:

   *  Extract native_callback_uri's DNS domain.

   *  Add the path /.well-known/openid-federation and perform trust
      chain resolution.

   *  Inspect client's metadata for redirect_uri's and validate
      *native_callback_uri* is included among them.

   When the client is invoked on its native_callback_uri, it shall
   regard the invocation as a response *from* the authorization server
   which redirected the client to the app.  In other words, this
   response's audience is not the authorization server which redirected
   the client to the app.  See Section 5.2.2.1 for details.

   Example URI used to invoke of client app on its claimed
   native_callback_uri:

   https://client.example.com/cb?authorization_code=uY29tL2F1dGhlbnRpY

   Example client invoking the response_uri *of the authorization server
   which federated it* to the authorization server, which redirected it
   to the app:

   POST /native-authorization HTTP/1.1
   Host: **prev-as.com**
   Content-Type: application/x-www-form-urlencoded

   authorization_code=uY29tL2F1dGhlbnRpY
   &auth_session=ce6772f5e07bc8361572f

5.2.2.3.  Additional Information Required Response

   If additional user input is required, for example to determine where
   to federate to, the response body shall contain the following
   additional properties:

   logo:  OPTIONAL.  URL or base64-encoded logo of _Authorization
      Server_, for branding purposes.

   userPrompt:  REQUIRED.  A JSON object containing the prompt
      definition.  The following parameters MAY be used:

   *  options: OPTIONAL.  A JSON object that defines a dropdown/select
      input with various options to choose from.  Each key is the
      parameter name to be sent in the response and each value defines
      the option:

      -  title: OPTIONAL.  A string holding the input's title.

      -  description: OPTIONAL.  A string holding the input's
         description.

      -  values: REQUIRED.  A JSON object where each key is the
         selection value and each value holds display data for that
         value:

         o  name: REQUIRED.  A string holding the display name of the
            selection value.

         o  logo: OPTIONAL.  A string holding a URL or base64-encoded
            image for that selection value.

   *  inputs: OPTIONAL.  A JSON object that defines an input field.
      Each key is the parameter name to be sent in the response and each
      value defines the input field:

      -  title: OPTIONAL.  A string holding the input's title.

      -  hint: OPTIONAL.  A string holding the input's hint that is
         displayed if the input is empty.

      -  description: OPTIONAL.  A string holding the input's
         description.

   Example of requesting end-user for 2 multiple-choice inputs:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "insufficient_information",
       "auth_session": "ce6772f5e07bc8361572f",
       "logo": "uri or base64-encoded logo of Authorization Server",
       "userPrompt": {
           "options": {
               "bank": {
                   "title": "Bank",
                   "description": "Choose your Bank",
                   "values": {
                       "bankOfSomething": {
                           "name": "Bank of Something",
                           "logo": "uri or base64-encoded logo"
                       },
                       "firstBankOfCountry": {
                           "name": "First Bank of Country",
                           "logo": "uri or base64-encoded logo"
                       }
                   }
               },
               "segment": {
                   "title": "Customer Segment",
                   "description": "Choose your Customer Segment",
                   "values": {
                       "retail": "Retail",
                       "smb": "Small & Medium Businesses",
                       "corporate": "Corporate",
                       "ic": "Institutional Clients"
                   }
               }
           }
       }
   }

   Example of requesting end-user for text input entry (email):

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "insufficient_information",
       "auth_session": "ce6772f5e07bc8361572f",
       "action": "prompt",
       "id": "request-identifier-2",
       "logo": "uri or base64-encoded logo of Authorization Server",
       "userPrompt": {
           "inputs": {
               "email": {
                   "hint": "Enter your email address",
                   "title": "E-Mail",
                   "description": "Lorem Ipsum"
               }
           }
       }
   }

   The client gathers the required additional information and makes a
   POST request to the Native Authorization Endpoint.  Example of
   response following end-user multiple-choice:

   POST /native-authorization HTTP/1.1
   Host: example.as.com
   Content-Type: application/x-www-form-urlencoded

   auth_session=ce6772f5e07bc8361572f
   &bank=bankOfSomething
   &segment=retail

   Example of _Client App_ response following end-user input entry:

   POST /native-authorization HTTP/1.1
   Host: example.as.com
   Content-Type: application/x-www-form-urlencoded

   auth_session=ce6772f5e07bc8361572f
   &email=end_user@example.as.com

5.2.2.4.  Redirect to Web Error Response

   The authorization server may choose to interact directly with the
   user based on a risk assesment, the introduction of a new
   authentication method not supported in the application, or to handle
   an exception flow like account recovery.  To indicate this error to
   the client, the authorization server returns an error response as
   defined above with the redirect_to_web error code.

   In this case, the client is expected to initiate a new OAuth
   Authorization Code flow with PKCE according to [RFC6749] and
   [RFC7636].

   If the client expects the frequency of this error response to be
   high, the client MAY include a PKCE [RFC7636] code_challenge in the
   initial authorization challenge request.  This enables the
   authorization server to essentially treat the authorization challenge
   request as a PAR [RFC9126] request, and return the request_uri and
   expires_in as defined by [RFC9126] in the error response.  The client
   then uses the request_uri value to build an authorization request as
   defined in [RFC9126] Section 4.

5.3.  Intermediate Requests

   If the authorization server returns an insufficient_authorization
   error as described above, this is an indication that there is further
   information the client should request from the user, and continue to
   make requests to the authorization server until the authorization
   request is fulfilled and an authorization code returned.

   These intermediate requests are out of scope of this specification,
   and are expected to be defined by the authorization server.  The
   format of these requests is not required to conform to the format of
   the initial authorization challenge requests (e.g. the request format
   may be application/json rather than application/x-www-form-
   urlencoded).

   These intermediate requests MAY also be sent to proprietary endpoints
   at the authorization server rather than the Native Authorization
   Endpoint.

5.3.1.  Auth Session

   The auth_session is a value that the authorization server issues in
   order to be able to associate subsequent requests from the same
   client.  It is intended to be analagous to how a browser cookie
   associates multiple requests by the same browser to the authorization
   server.

   The auth_session value is completely opaque to the client, and as
   such the authorization server MUST adequately protect the value from
   inspection by the client, for example by using a random string or
   using a JWE if the authorization server is not maintaining state on
   the backend.

   If the client has an auth_session, the client MUST include it in
   future requests to the native authorization endpoint of the
   respective authorization server that provided it.  The client MUST
   store the auth_session beyond the issuance of the authorization code
   to be able to use it in future requests.

   Every response defined by this specification may include a new
   auth_session value.  Clients MUST NOT assume that auth_session values
   are static, and MUST be prepared to update the stored auth_session
   value if one is received in a response.

   To mitigate the risk of session hijacking, the 'auth_session' MUST be
   bound to the device, and the authorization server MUST reject an
   'auth_session' if it is presented from a different device than the
   one it was bound to.

   See Section 9.5 for additional security considerations.

6.  Token Request

   The client makes a request to the token endpoint using the
   authorization code it obtained from the native authorization
   endpoint.

   This specification does not define any additional parameters beyond
   the token request parameters defined in Section 4.1.3 of [RFC6749].
   However, notably, the redirect_uri parameter will not be included in
   this request, because no redirect_uri parameter was included in the
   authorization request.

6.1.  Token Endpoint Successful Response

   This specification extends the OAuth 2.0 [RFC6749] token response
   defined in Section 5.1 with the additional parameter auth_session,
   defined in Section 5.3.1.

   An example successful token response is below:

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "access_token": "2YotnFZFEjr1zCsicMWpAA",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",
     "auth_session": "uY29tL2F1dGhlbnRpY"
   }

   The response MAY include an auth_session parameter which the client
   is expected to include on any subsequent requests to the native
   challenge endpoint, as described in Section 5.3.1.  The auth_session
   parameter MAY also be included even if the authorization code was
   obtained through a traditional OAuth authorization code flow rather
   than the flow defined by this specification.

   Including the auth_session parameter in the token response enables
   flows such as step-up authentication [RFC9470], so that the
   authorization server can restore the context of a previous session
   and prompt only for the needed step-up factors.  See Appendix A.8 for
   an example application.

6.2.  Token Endpoint Error Response

   Upon any request to the token endpoint, including a request with a
   valid refresh token, the authorization server can respond with an
   authorization challenge instead of a successful access token
   response.

   An authorization challenge error response is a particular type of
   error response as defined in Section 5.2 of OAuth 2.0 [RFC6749] where
   the error code is set to the following value:

   "error": "insufficient_authorization":  The presented authorization
      is insufficient, and the authorization server is requesting the
      client take additional steps to complete the authorization.

   Additionally, the response MAY contain an auth_session parameter
   which the client is expected to include on a subsequent request to
   the native authorization endpoint.

   "auth_session":  OPTIONAL.  The optional auth session value allows
      the authorization server to associate subsequent requests by this
      client with an ongoing authorization request sequence.  The client
      MUST include the auth_session in follow-up requests to the native
      authorizaion endpoint if it receives one along with the error
      response.

   For example:

   HTTP/1.1 403 Forbidden
   Content-Type: application/json
   Cache-Control: no-store

   {
     "error": "insufficient_authorization",
     "auth_session": "ce6772f5e07bc8361572f"
   }

7.  Resource Server Error Response

   Step-Up Authentication [RFC9470] defines new error code values that a
   resource server can use to tell the client to start a new
   authorization request including acr_values and max_age from [OpenID].
   Upon receiving this error response, the client starts a new first-
   party authorization request at the native authorization endpoint, and
   includes the acr_values, max_age and scope that were returned in the
   error response.

   This specification does not define any new parameters for the
   resource server error response beyond those defined in [RFC9470] and
   [RFC6750].

8.  Authorization Server Metadata

   The following authorization server metadata parameters [RFC8414] are
   introduced to signal the server's capability and policy with respect
   to first-party applications.

   "native_authorization_endpoint":  The URL of the native authorization
      endpoint at which a client can initiate an authorization request
      and eventually obtain an authorization code.

9.  Security Considerations

9.1.  First-Party Applications

   First-party applications are applications that are controlled by the
   same entity as the authorization server used by the application, and
   the user understands them both as the same entity.

   For first-party applications, it is important that the user
   recognizes the application and authorization server as belonging to
   the same brand.  For example, a bank publishing their own mobile
   application.

   Because this specification enables a client application to interact
   directly with the end user, and the application handles sending any
   information collected from the user to the authorization server, it
   is expected to be used only for first-party applications when the
   authorization server also has a high degree of trust of the client.

   This specification is not prescriptive on how the Authorization
   Server establishes its trust in the first-partyness of the
   application.  For mobile platforms, most support some mechanism for
   application attestation that can be used to identify the entity that
   created/signed/uploaded the app to the app store.  App attestation
   can be combined with mechanisms such as Attestation-Based Client
   Authentication [[I-D.ietf-oauth-attestation-based-client-auth]] or
   Dynamic Client Registration [RFC7591] to enable strong client
   authentication in addition to client verification (first-partyness).
   The exact steps required are out of scope for this specification.
   Note that applications running inside a browser (e.g. Single Page
   Apps) context it is much more difficult to verify the first-partyness
   of the client.  Please see Section 9.7 for additional details.

9.2.  Phishing

   There are two ways using this specification increases the risk of
   phishing.

   1.  Malicious application: With this specification, the client
       interacts directly with the end user, collecting information
       provided by the user and sending it to the authorization server.
       If an attacker impersonates the client and successfully tricks a
       user into using it, they may not realize they are giving their
       credentials to the malicious application.

   2.  User education: In a traditional OAuth deployment using the
       redirect-based authorization code flow, the user will only ever
       enter their credentials at the authorization server, and it is
       straightforward to explain to avoid entering credentials in other
       "fake" websites.  By introducing a new place the user is expected
       to enter their credentials using this specification, it is more
       complicated to teach users how to recognize other fake login
       prompts that might be attempting to steal their credentials.

   Because of these risks, the authorization server MAY decide to
   require that the user go through a redirect-based flow at any stage
   of the process based on its own risk assessment.

9.3.  Credential Stuffing Attacks

   The native authorization endpoint is capable of directly receiving
   user credentials and returning authorization codes.  This exposes a
   new vector to perform credential stuffing attacks, if additional
   measures are not taken to ensure the authenticity of the application.

   An authorization server may already have a combination of built-in or
   3rd party security tools in place to monitor and reduce this risk in
   browser-based authentication flows.  Implementors SHOULD consider
   similar security measures to reduce this risk in the native
   authorization endpoint.  Additionally, the attestation APIs SHOULD be
   used when possible to assert a level of confidence to the
   authorization server that the request is originating from an
   application owned by the same party.

9.4.  Sender-Constrained Tokens

   Tokens issued in response to an authorization challenge request
   SHOULD be sender constrained to mitigate the risk of token theft and
   replay.

   Proof-of-Possession techniques constrain tokens by binding them to a
   cryptographic key.  Whenever the token is presented, it MUST be
   accompanied by a proof that the client presenting the token also
   controls the cryptographic key bound to the token.  If a proof-of-
   possession sender constrained token is presented without valid proof
   of possession of the cryptographic key, it MUST be rejected.

9.4.1.  DPoP: Demonstrating Proof-of-Possession

   DPoP [RFC9449] is an application-level mechanism for sender-
   constraining OAuth [RFC6749] access and refresh tokens.  If DPoP is
   used to sender constrain tokens, the client SHOULD use DPoP for every
   token request to the Authorization Server and interaction with the
   Resource Server.

   DPoP includes an optional capability to bind the authorization code
   to the DPoP key to enable end-to-end binding of the entire
   authorization flow.  Given the back-channel nature of this
   specification, there are far fewer opportunities for an attacker to
   access the authorization code and PKCE code verifier compared to the
   redirect-based Authorization Code Flow.  In this specification, the
   Authorization Code is obtained via a back-channel request.  Despite
   this, omitting Authorization Code binding leaves a gap in the end-to-
   end protection that DPoP provides, so DPoP Authorization Code binding
   SHOULD be used.

   The mechanism for Authorization Code binding with DPoP is similar as
   that defined for Pushed Authorization Requests (PARs) in Section 10.1
   of [RFC9449].  In order to bind the Authorization Code with DPoP, the
   client MUST add the DPoP header to the Authorization Challenge
   Request.  The authorization server MUST check the DPoP proof JWT that
   was included in the DPoP header as defined in Section 4.3 of
   [RFC9449].  The authorization server MUST ensure that the same key is
   used in all subsequent Authorization Challenge Requests and in the
   eventual token request.  The authorization server MUST reject
   subsequent Authorization Challenge Requests, or the eventual token
   request, unless a DPoP proof for the same key presented in the
   original Authorization Challenge Request is provided.

   The above mechanism simplifies the implementation of the client, as
   it can attach the DPoP header to all requests to the authorization
   server regardless of the type of request.  This mechanism provides a
   stronger binding than using the dpop_jkt parameter, as the DPoP
   header contains a proof of possession of the private key.

9.4.2.  Other Proof of Possession Mechanisms

   It may be possible to use other proof of possession mechanisms to
   sender constrain access and refresh tokens.  Defining these
   mechanisms are out of scope for this specification.

9.5.  Auth Session

9.5.1.  Auth Session DPoP Binding

   If the client and authorization server are using DPoP binding of
   access tokens and/or authorization codes, then the auth_session value
   SHOULD be protected as well.  The authorization server SHOULD
   associate the auth_session value with the DPoP public key.  This
   removes the need for the authorization server to include additional
   claims in the DPoP proof, while still benefitting from the assurance
   that the client presenting the proof has control over the DPoP key.
   To associate the auth_session value with the DPoP public key, the
   authorization server:

   *  MUST check that the same DPoP public key is being used when the
      client presents the DPoP proof.

   *  MUST verify the DPoP proof to ensure the client controls the
      corresponding private key whenever the client includes the
      auth_session in an Authorization Challenge Request as described in
      Section 5.1.

   DPoP binding of the auth_session value ensures that the context
   referenced by the auth_session cannot be stolen and reused by another
   device.

9.5.2.  Auth Session Lifetime

   This specification makes no requirements or assumptions on the
   lifetime of the auth_session value.  The lifetime and expiration is
   at the discretion of the authorization server, and the authorization
   server may choose to invalidate the value for any reason such as
   scheduled expiration, security events, or revocation events.

   Clients MUST NOT make any assumptions or depend on any particular
   lifetime of the auth_session value.

9.6.  Multiple Applications

   When multiple first-party applications are supported by the AS, then
   it is important to consider a number of additional risks.  These
   risks fall into two main categories: Experience Risk and Technical
   Risk which are described below.

9.6.1.  User Experience Risk

   Any time a user is asked to provide the authentication credentials in
   user experiences that differ, it has the effect of increasing the
   likelihood that the user will fall prey to a phishing attack because
   they are used to entering credentials in different looking
   experiences.  When multiple first-party applications are supported,
   the implementation MUST ensure the native experience is identical
   across all the first-party applications.

   Another experience risk is user confusion caused by different looking
   experiences and behaviors.  This can increase the likelihood the user
   will not complete the authentication experience for the first-party
   application.

9.6.2.  Technical Risk

   In addition to the experience risks, multiple implementations in
   first-party applications increases the risk of an incorrect
   implementation as well as increasing the attack surface as each
   implementation may expose its own weaknesses.

9.6.3.  Mitigation

   To address these risks, when multiple first-party applications must
   be supported, and other methods such as [OpenID.Native-SSO] are not
   applicable, it is RECOMMENDED that a client-side SDK be used to
   ensure the implementation is consistent across the different
   applications and to ensure the user experience is identical for all
   first-party apps.

9.7.  Single Page Applications

   Single Page Applications (SPA) run in a scripting language inside the
   context of a browser instance.  This environment poses several unique
   challenges compared to native applications, in particular:

   *  Significant attack vectors due to the possibility of Cross-Site
      Scripting (XSS) attacks

   *  Fewer options to securely attest to the first-partyness of a
      browser based application

   See [I-D.ietf-oauth-browser-based-apps] for a detailed discussion of
   the risks of XSS attacks in browsers.

   Additionally, the nature of a Single-Page App means the user is
   already in a browser context, so the user experience cost of doing a
   full page redirect or a popup window for the traditional OAuth
   Authorization Code Flow is much less than the cost of doing so in a
   native application.  The complexity and risk of implementing this
   specification in a browser likely does not outweigh the user
   experience benefits that would be gained in that context.

   For these reasons, it is NOT RECOMMENDED to use this specification in
   browser-based applications.

10.  IANA Considerations

10.1.  OAuth Parameters Registration

   IANA has (TBD) registered the following values in the IANA "OAuth
   Parameters" registry of [IANA.oauth-parameters] established by
   [RFC6749].

   *Parameter name*: auth_session

   *Parameter usage location*: token response

   *Change Controller*: IETF

   *Specification Document*: Section 5.4 of this specification

10.2.  OAuth Server Metadata Registration

   IANA has (TBD) registered the following values in the IANA "OAuth
   Authorization Server Metadata" registry of [IANA.oauth-parameters]
   established by [RFC8414].

   *Metadata Name*: native_authorization_endpoint

   *Metadata Description*: URL of the authorization server's native
   authorization endpoint.

   *Change Controller*: IESG

   *Specification Document*: Section 4.1 of [[ this specification ]]

11.  References

11.1.  Normative References

   [I-D.ietf-oauth-cross-device-security]
              Kasselman, P., Fett, D., and F. Skokan, "Cross-Device
              Flows: Security Best Current Practice", Work in Progress,
              Internet-Draft, draft-ietf-oauth-cross-device-security-13,
              2 December 2025, <https://datatracker.ietf.org/doc/html/
              draft-ietf-oauth-cross-device-security-13>.

   [I-D.ietf-oauth-first-party-apps]
              Parecki, A., Fletcher, G., and P. Kasselman, "OAuth 2.0
              for First-Party Applications", Work in Progress, Internet-
              Draft, draft-ietf-oauth-first-party-apps-02, 20 October
              2025, <https://datatracker.ietf.org/doc/html/draft-ietf-
              oauth-first-party-apps-02>.

   [IANA.JWT] "*** BROKEN REFERENCE ***".

   [IANA.oauth-parameters]
              IANA, "OAuth Parameters",
              <https://www.iana.org/assignments/oauth-parameters>.

   [OpenID]   Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and
              C. Mortimore, "OpenID Connect Core 1.0", November 2014,
              <https://openid.net/specs/openid-connect-core-1_0.html>.

   [OpenID.Federation]
              Hedberg, Ed, R., Jones, M. B., Solberg, A. A., Bradley,
              J., De Marco, G., and V. Dzhuvinov, "OpenID Federation
              1.0", March 2025,
              <https://openid.net/specs/openid-federation-1_0.html>.

   [OpenID.Native-SSO]
              Fletcher, G., "OpenID Connect Native SSO for Mobile Apps",
              November 2022, <https://openid.net/specs/openid-connect-
              native-sso-1_0.html>.

   [OpenID4VP]
              Terbu, O., Lodderstedt, T., Yasuda, K., Fett, D., and J.
              Heenan, "OpenID for Verifiable Presentations 1.0", July
              2025, <https://openid.net/specs/openid-4-verifiable-
              presentations-1_0.html>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6749]  Hardt, D., Ed., "The OAuth 2.0 Authorization Framework",
              RFC 6749, DOI 10.17487/RFC6749, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6749>.

   [RFC7159]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014, <https://www.rfc-editor.org/rfc/rfc7159>.

   [RFC7515]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", RFC 7515, DOI 10.17487/RFC7515, May
              2015, <https://www.rfc-editor.org/rfc/rfc7515>.

   [RFC7519]  Jones, M., Bradley, J., and N. Sakimura, "JSON Web Token
              (JWT)", RFC 7519, DOI 10.17487/RFC7519, May 2015,
              <https://www.rfc-editor.org/rfc/rfc7519>.

   [RFC7591]  Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and
              P. Hunt, "OAuth 2.0 Dynamic Client Registration Protocol",
              RFC 7591, DOI 10.17487/RFC7591, July 2015,
              <https://www.rfc-editor.org/rfc/rfc7591>.

   [RFC7636]  Sakimura, N., Ed., Bradley, J., and N. Agarwal, "Proof Key
              for Code Exchange by OAuth Public Clients", RFC 7636,
              DOI 10.17487/RFC7636, September 2015,
              <https://www.rfc-editor.org/rfc/rfc7636>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8259]  Bray, T., Ed., "The JavaScript Object Notation (JSON) Data
              Interchange Format", STD 90, RFC 8259,
              DOI 10.17487/RFC8259, December 2017,
              <https://www.rfc-editor.org/rfc/rfc8259>.

   [RFC8414]  Jones, M., Sakimura, N., and J. Bradley, "OAuth 2.0
              Authorization Server Metadata", RFC 8414,
              DOI 10.17487/RFC8414, June 2018,
              <https://www.rfc-editor.org/rfc/rfc8414>.

   [RFC8628]  Denniss, W., Bradley, J., Jones, M., and H. Tschofenig,
              "OAuth 2.0 Device Authorization Grant", RFC 8628,
              DOI 10.17487/RFC8628, August 2019,
              <https://www.rfc-editor.org/rfc/rfc8628>.

   [RFC8707]  Campbell, B., Bradley, J., and H. Tschofenig, "Resource
              Indicators for OAuth 2.0", RFC 8707, DOI 10.17487/RFC8707,
              February 2020, <https://www.rfc-editor.org/rfc/rfc8707>.

   [RFC9126]  Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D.,
              and F. Skokan, "OAuth 2.0 Pushed Authorization Requests",
              RFC 9126, DOI 10.17487/RFC9126, September 2021,
              <https://www.rfc-editor.org/rfc/rfc9126>.

   [RFC9396]  Lodderstedt, T., Richer, J., and B. Campbell, "OAuth 2.0
              Rich Authorization Requests", RFC 9396,
              DOI 10.17487/RFC9396, May 2023,
              <https://www.rfc-editor.org/rfc/rfc9396>.

   [RFC9449]  Fett, D., Campbell, B., Bradley, J., Lodderstedt, T.,
              Jones, M., and D. Waite, "OAuth 2.0 Demonstrating Proof of
              Possession (DPoP)", RFC 9449, DOI 10.17487/RFC9449,
              September 2023, <https://www.rfc-editor.org/rfc/rfc9449>.

   [RFC9470]  Bertocci, V. and B. Campbell, "OAuth 2.0 Step Up
              Authentication Challenge Protocol", RFC 9470,
              DOI 10.17487/RFC9470, September 2023,
              <https://www.rfc-editor.org/rfc/rfc9470>.

   [SHS]      Technology, N. I. of S. and., ""Secure Hash Standard
              (SHS)", FIPS PUB 180-4, DOI 10.6028/NIST.FIPS.180-4",
              August 2015, <http://dx.doi.org/10.6028/NIST.FIPS.180-4>.

   [USASCII]  Institute, A. N. S., "Coded Character Set -- 7-bit
              American Standard Code for Information Interchange, ANSI
              X3.4", 1986.

11.2.  Informative References

   [I-D.ietf-oauth-attestation-based-client-auth]
              Looker, T., Bastian, P., and C. Bormann, "OAuth 2.0
              Attestation-Based Client Authentication", Work in
              Progress, Internet-Draft, draft-ietf-oauth-attestation-
              based-client-auth-07, 15 September 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-oauth-
              attestation-based-client-auth-07>.

   [I-D.ietf-oauth-browser-based-apps]
              Parecki, A., De Ryck, P., and D. Waite, "OAuth 2.0 for
              Browser-Based Applications", Work in Progress, Internet-
              Draft, draft-ietf-oauth-browser-based-apps-26, 3 December
              2025, <https://datatracker.ietf.org/doc/html/draft-ietf-
              oauth-browser-based-apps-26>.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", RFC 6750,
              DOI 10.17487/RFC6750, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6750>.

   [RFC8252]  Denniss, W. and J. Bradley, "OAuth 2.0 for Native Apps",
              BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017,
              <https://www.rfc-editor.org/rfc/rfc8252>.

Appendix A.  Example User Experiences

   This section provides non-normative examples of how this
   specification may be used to support specific use cases.

A.1.  Passkey

   A user may log in with a passkey (without a password).

   1.  The Client collects the username from the user.

   2.  The Client sends an Authorization Challenge Request (Section 5.1)
       to the Native Authorization Endpoint (Section 4.1) including the
       username.

   3.  The Authorization Server verifies the username and returns a
       challenge

   4.  The Client signs the challenge using the platform authenticator,
       which results in the user being prompted for verification with
       biometrics or a PIN.

   5.  The Client sends the signed challenge, username, and credential
       ID to the Native Authorization Endpoint (Section 4.1).

   6.  The Authorization Server verifies the signed challenge and
       returns an Authorization Code.

   7.  The Client requests an Access Token and Refresh Token by issuing
       a Token Request (Section 6) to the Token Endpoint.

   8.  The Authorization Server verifies the Authorization Code and
       issues the requested tokens.

A.2.  Redirect to Authorization Server

   A user may be redirected to the Authorization Server to perfrom an
   account reset.

   1.  The Client collects username from the user.

   2.  The Client sends an Authorization Challenge Request (Section 5.1)
       to the Native Authorization Endpoint (Section 4.1) including the
       username.

   3.  The Authorization Server verifies the username and determines
       that the account is locked and returns a Redirect error response.

   4.  The Client parses the redirect message, opens a browser and
       redirects the user to the Authorization Server performing an
       OAuth 2.0 flow with PKCE.

   5.  The user resets their account by performing a multi-step
       authentication flow with the Authorization Server.

   6.  The Authorization Server issues an Authorization Code in a
       redirect back to the client, which then exchanges it for an
       access and refresh token.

A.3.  Native client federated and redirected to app

A.3.1.  Diagram

                                                  +--------------------+
                                                  |   Authorization    |
                            (B)Native             |      Server 1      |
               +----------+ Authorization Request |+------------------+|
  (A)User  +---|          |---------------------->||     Native       ||
     Starts|   |          |                       ||  Authorization   ||
     Flow  +-->|  Client  |<----------------------||    Endpoint      ||
               |          | (C)Federate Error     |+------------------+|
               |          |        Response       +--------------------+
               |          |         :
               |          |         :             +--------------------+
               |          |         :             |   Authorization    |
               |          | (D)Native             |      Server 2      |
               |          | Authorization Request |+------------------+|
               |          |---------------------->||     Native       ||
               |          |                       ||  Authorization   ||
               |          |<----------------------||    Endpoint      ||
               |          | (E) Redirect to       |+------------------+|
               |          |     App Response      +--------------------+
               |          |         :
               |          |         :             +--------------------+
               |          | (F) Invoke App        |                    |
               |          |---------------------->|   Native App of    |
               |          |                       |   Auth Server 2    |
               |          |<----------------------|                    |
               |          | (G)Authorization code +--------------------+
               |          |   For Auth Server 1
               |          |         :             +--------------------+
               |          |         :             |   Authorization    |
               |          | (H)Authorization Code |      Server 1      |
               |          |    For Auth Server 1  |+------------------+|
               |          |---------------------->||    Response      ||
               |          |                       ||       Uri        ||
               |          |<----------------------||    Endpoint      ||
               |          | (I) Authorization     |+------------------+|
               |          |     Code Response     |                    |
               |          |         :             |                    |
               |          |         :             |                    |
               |          | (J) Token Request     |+------------------+|
               |          |---------------------->||      Token       ||
               |          |                       ||     Endpoint     ||
               |          |<----------------------||                  ||
               |          | (K) Access Token      |+------------------+|
               |          |                       +--------------------+
               |          |
               +----------+

   Figure: Native client federated, then redirected to app

A.3.2.  Client makes initial request and receives "federate" error

   Client calls the native authorization endpoint and includes the
   _native_callback_uri_ parameter:

   POST /native-authorization HTTP/1.1
   Host: as-1.com
   Content-Type: application/x-www-form-urlencoded

   client_id=t7CieSlru4&native_callback_uri=
   https://client.example.com/cb

   The first authorization server, as-1.com, decides to federate to as-
   2.com after validating it supports the native authorization endpoint.
   If it does not, as-1.com returns:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "native_authorization_federate_unsupported"
   }

   If native authorization endpoint is supported by the federated
   authorization server, as-1.com performs a PAR [RFC9126] request to
   as-2.com's pushed authorization endpoint, including the original
   _native_callback_uri_:

   POST /par HTTP/1.1
   Host: as-2.com
   Content-Type: application/x-www-form-urlencoded

   client_id=s6BhdRkqt3&native_callback_uri=
   https://client.example.com/cb

   as-1.com receives a request_uri from as-2.com's PAR endpoint, which
   it includes in its response to client, in the _federation_body_
   attribute:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "federate",
       "auth_session": "ce6772f5e07bc8361572f",
       "response_uri": "https://as-1.com/native-authorization",
       "federation_uri": "https://as-2.com/native-authorization",
       "federation_body": "client_id=s6BhdRkqt3&request_uri=
         urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX"
   }

   See Section 5.2.2.1 for more details.

A.3.3.  Client calls federated authorization server and is redirected to
        app

   Client calls the _federation_uri_ it got from as-1.com using HTTP
   POST with _federation_body_ as application/x-www-form-urlencoded
   request body:

   POST /native-authorization HTTP/1.1
   Host: as-2.com
   Content-Type: application/x-www-form-urlencoded

   client_id=s6BhdRkqt3&request_uri=
   urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX

   as-2.com decides to use its native app to interact with end-user and
   responds:

   HTTP/1.1 400 Bad Request
   Content-Type: application/json

   {
       "error": "redirect_to_app",
       "deep_link": "https://as-2.com/native-authorization?
         client_id=s6BhdRkqt3&request_uri=
         urn:ietf:params:oauth:request_uri:R3p_hzwsR7outNQSKfoX"
   }

   Client locates an app claiming the obtained deep_link and invokes it.
   See Section 5.2.2.2 for more details.  The invoked app handles the
   native authorization request and then natively invokes
   native_callback_uri:

   https://client.example.com/cb?authorization_code=uY29tL2F1dGhlbnRpY

A.3.4.  Client calls federating authorization server

   Client invokes the response_uri of as-1.com as it is the
   authorization server which federated it to as-2.com and the app's
   response is regarded as the response of as-2.com:

   POST /native-authorization HTTP/1.1
   Host: as-1.com
   Content-Type: application/x-www-form-urlencoded

   authorization_code=uY29tL2F1dGhlbnRpY
   &auth_session=ce6772f5e07bc8361572f

   And receives in response an authorization code, which it is the
   audience of (no further federations) to resolve:

   HTTP/1.1 200 OK
   Content-Type: application/json

   {
     "authorization_code": "vZ3:uM3G2eHimcoSqjZ"
   }

   Client proceeds to exchange code for tokens.

A.4.  Passwordless One-Time Password (OTP)

   In a passwordless One-Time Password (OTP) scheme, the user is in
   possession of a one-time password generator.  This generator may be a
   hardware device, or implemented as an app on a mobile phone.  The
   user provides a user identifier and one-time password, which is
   verified by the Authorization Server before it issues an
   Authorization Code, which can be exchanged for an Access and Refresh
   Token.

   1.  The Client collects username and OTP from user.

   2.  The Client sends an Authorization Challenge Request (Section 5.1)
       to the Native Authorization Endpoint (Section 4.1) including the
       username and OTP.

   3.  The Authorization Server verifies the username and OTP and
       returns an Authorization Code.

   4.  The Client requests an Access Token and Refresh Token by issuing
       a Token Request (Section 6) to the Token Endpoint.

   5.  The Authorization Server verifies the Authorization Code and
       issues the requested tokens.

A.5.  E-Mail Confirmation Code

   A user may be required to provide an e-mail confirmation code as part
   of an authentication ceremony to prove they control an e-mail
   address.  The user provides an e-mail address and is then required to
   enter a verification code sent to the e-mail address.  If the correct
   verification code is returned to the Authorization Server, it issues
   Access and Refresh Tokens.

   1.  The Client collects an e-mail address from the user.

   2.  The Client sends the e-mail address in an Authorization Challenge
       Request (Section 5.1) to the Native Authorization Endpoint
       (Section 4.1).

   3.  The Authorization Server sends a verification code to the e-mail
       address and returns an Error Response (Section 5.2.2) including
       "error": "insufficient_authorization", "auth_session" and a
       custom property indicating that an e-mail verification code must
       be entered.

   4.  The Client presents a user experience guiding the user to copy
       the e-mail verification code to the Client.  Once the e-mail
       verification code is entered, the Client sends an Authorization
       Challenge Request to the Native Authorization Endpoint, including
       the e-mail verification code as well as the auth_session
       parameter returned in the previous Error Response.

   5.  The Authorization Server uses the auth_session to maintain the
       session and verifies the e-mail verification code before issuing
       an Authorization Code to the Client.

   6.  The Client sends the Authorization Code in a Token Request
       (Section 6) to the Token Endpoint.

   7.  The Authorization Server verifies the Authorization Code and
       issues the Access Token and Refresh Token.

   An alternative version of this verification involves the user
   clicking a link in an email rather than manually entering a
   verification code.  This is typically done for email verification
   flows rather than inline in a login flow.  The protocol-level details
   remain the same for the alternative flow despite the different user
   experience.  All steps except step 4 above remain the same, but the
   client presents an alternative user experience for step 4 described
   below:

   *  The Client presents a message to the user instructing them to
      click the link sent to their email address.  The user clicks the
      link in the email, which contains the verification code in the
      URL.  The URL launches the app providing the verification code to
      the Client.  The Client sends the verification code and
      auth_session to the Native Authorization Endpoint.

A.6.  Mobile Confirmation Code

   A user may be required to provide a confirmation code as part of an
   authentication ceremony to prove they control a mobile phone number.
   The user provides a phone number and is then required to enter a
   confirmation code sent to the phone.  If the correct confirmation
   code is returned to the Authorization Server, it issues Access and
   Refresh Tokens.

   1.  The Client collects a mobile phone number from the user.

   2.  The Client sends the phone number in an Authorization Challenge
       Request (Section 5.1) to the Native Authorization Endpoint
       (Section 4.1).

   3.  The Authorization Server sends a confirmation code to the phone
       number and returns an Error Response (Section 5.2.2) including
       "error": "insufficient_authorization", "auth_session" and a
       custom property indicating that a confirmation code must be
       entered.

   4.  The Client presents a user experience guiding the user to enter
       the confirmation code.  Once the code is entered, the Client
       sends an Authorization Challenge Request to the Native
       Authorization Endpoint, including the confirmation code as well
       as the auth_session parameter returned in the previous Error
       Response.

   5.  The Authorization Server uses the auth_session to maintain the
       session context and verifies the code before issuing an
       Authorization Code to the Client.

   6.  The Client sends the Authorization Code in a Token Request
       (Section 6) to the Token Endpoint.

   7.  The Authorization Server verifies the Authorization Code and
       issues the Access Token and Refresh Token.

A.7.  Re-authenticating to an app a week later using OTP

   A client may be in possession of an Access and Refresh Token as the
   result of a previous succesful user authentication.  The user returns
   to the app a week later and accesses the app.  The Client presents
   the Access Token, but receives an error indicating the Access Token
   is no longer valid.  The Client presents a Refresh Token to the
   Authorization Server to obtain a new Access Token.  If the
   Authorization Server requires user interaction for reasons based on
   its own policies, it rejects the Refresh Token and the Client re-
   starts the user authentication flow to obtain new Access and Refresh
   Tokens.

   1.   The Client has a short-lived access token and long-lived refresh
        token following a previous completion of an Authorization Grant
        Flow which included user authentication.

   2.   A week later, the user launches the app and tries to access a
        protected resource at the Resource Server.

   3.   The Resource Server responds with an error code indicating an
        invalid access token since it has expired.

   4.   The Client presents the refresh token to the Authorization
        Server to obtain a new access token (section 6 [RFC6749])

   5.   The Authorization Server responds with an error code indicating
        that an OTP from the user is required, as well as an
        auth_session.

   6.   The Client prompts the user to enter an OTP.

   7.   The Client sends the OTP and auth_session in an Authorization
        Challenge Request (Section 5.1) to the Native Authorization
        Endpoint (Section 4.1).

   8.   The Authorization Server verifies the auth_session and OTP, and
        returns an Authorization Code.

   9.   The Client sends the Authorization Code in a Token Request
        (Section 6) to the Token Endpoint.

   10.  The Authorization Server verifies the Authorization Code and
        issues the requested tokens.

   11.  The Client presents the new Access Token to the Resource Server
        in order to access the protected resource.

A.8.  Step-up Authentication using Confirmation SMS

   A Client previously obtained an Access and Refresh Token after the
   user authenticated with an OTP.  When the user attempts to access a
   protected resource, the Resource Server determines that it needs an
   additional level of authentication and triggers a step-up
   authentication, indicating the desired level of authentication using
   acr_values and max_age as defined in the Step-up Authentication
   specification.  The Client initiates an authorization request with
   the Authorization Server indicating the acr_values and max_age
   parameters.  The Authorization Server responds with error messages
   promptng for additional authentication until the acr_values and
   max_age values are satisfied before issuing fresh Access and Refresh
   Tokens.

   1.   The Client has a short-lived access token and long-lived refresh
        token following the completion of an Authorization Code Grant
        Flow which included user authentication.

   2.   When the Client presents the Access token to the Resource
        Server, the Resource Server determines that the acr claim in the
        Access Token is insufficient given the resource the user wants
        to access and responds with an insufficient_user_authentication
        error code, along with the desired acr_values and desired
        max_age.

   3.   The Client sends an Authorization Challenge Request
        (Section 5.1) to the Native Authorization Endpoint (Section 4.1)
        including the auth_session, acr_values and max_age parameters.

   4.   The Authorization Server verifies the auth_session and
        determines which authentication methods must be satisfied based
        on the acr_values, and responds with an Error Response
        (Section 5.2.2) including "error": "insufficient_authorization"
        and a custom property indicating that an OTP must be entered.

   5.   The Client prompts the user for an OTP, which the user obtains
        and enters.

   6.   The Client sends an Authorization Challenge Request to the
        Native Authorization Endpoint including the auth_session and
        OTP.

   7.   The Authorization Server verifies the OTP and returns an
        Authorization Code.

   8.   The Client sends the Authorization Code in a Token Request
        (Section 6) to the Token Endpoint.

   9.   The Authorization Server verifies the Authorization Code and
        issues an Access Token with the updated acr value along with the
        Refresh Token.

   10.  The Client presents the Access Token to the Resources Server,
        which verifies that the acr value meets its requirements before
        granting access to the protected resource.

A.9.  Registration

   This example describes how to use the mechanisms defined in this
   draft to create a complete user registration flow starting with an
   email address.  In this example, it is the Authorization Server's
   policy to allow these challenges to be sent to email and phone number
   that were previously unrecognized, and creating the user account on
   the fly.

   1.   The Client collects a username from the user.

   2.   The Client sends an Authorization Challenge Request
        (Section 5.1) to the Native Authorization Endpoint (Section 4.1)
        including the username.

   3.   The Authorization Server returns an Error Response
        (Section 5.2.2) including "error": "insufficient_authorization",
        "auth_session", and a custom property indicating that an e-mail
        address must be collected.

   4.   The Client collects an e-mail address from the user.

   5.   The Client sends the e-mail address as part of a second
        Authorization Challenge Request to the Native Authorization
        Endpoint, along with the auth_session parameter.

   6.   The Authorization Server sends a verification code to the e-mail
        address and returns an Error Response including "error":
        "insufficient_authorization", "auth_session" and a custom
        property indicating that an e-mail verification code must be
        entered.

   7.   The Client presents a user experience guiding the user to copy
        the e-mail verification code to the Client.  Once the e-mail
        verification code is entered, the Client sends an Authorization
        Challenge Request to the Native Authorization Endpoint,
        including the e-mail verification code as well as the
        auth_session parameter returned in the previous Error Response.

   8.   The Authorization Server uses the auth_session to maintain the
        session context, and verifies the e-mail verification code.  It
        determines that it also needs a phone number for account
        recovery purposes and returns an Error Response including
        "error": "insufficient_authorization", "auth_session" and a
        custom property indicating that a phone number must be
        collected.

   9.   The Client collects a mobile phone number from the user.

   10.  The Client sends the phone number in an Authorization Challenge
        Request to the Native Authorization Endpoint, along with the
        auth_session.

   11.  The Authorization Server uses the auth_session parameter to link
        the previous requests.  It sends a confirmation code to the
        phone number and returns an Error Response including "error":
        "insufficient_authorization", "auth_session" and a custom
        property indicating that a SMS confirmation code must be
        entered.

   12.  The Client presents a user experience guiding the user to enter
        the SMS confirmation code.  Once the SMS verification code is
        entered, the Client sends an Authorization Challenge Request to
        the Native Authorization Endpoint, including the confirmation
        code as well as the auth_session parameter returned in the
        previous Error Response.

   13.  The Authorization Server uses the auth_session to maintain the
        session context, and verifies the SMS verification code before
        issuing an Authorization Code to the Client.

   14.  The Client sends the Authorization Code in a Token Request
        (Section 6) to the Token Endpoint.

   15.  The Authorization Server verifies the Authorization Code and
        issues the requested tokens.

Appendix B.  Example Implementations

   In order to successfully implement this specification, the
   Authorization Server will need to define its own specific
   requirements for what values clients are expected to send in the
   Authorization Challenge Request (Section 5.1), as well as its own
   specific error codes in the Authorization Challenge Response
   (Section 5.2).

   Below is an example of parameters required for a complete
   implementation that enables the user to log in with a username and
   OTP.

B.1.  Authorization Challenge Request Parameters

   In addition to the request parameters defined in Section 5.1, the
   authorization server defines the additional parameters below.

   "username":  REQUIRED for the initial Authorization Challenge
      Request.

   "otp":  The OTP collected from the user.  REQUIRED when re-trying an
      Authorization Challenge Request in response to the otp_required
      error defined below.

B.2.  Authorization Challenge Response Parameters

   In addition to the response parameters defined in Section 5.2, the
   authorization server defines the additional value for the error
   response below.

   "otp_required":  The client should collect an OTP from the user and
      send the OTP in a second request to the Native Authorization
      Endpoint.  The HTTP response code to use with this error value is
      401 Unauthorized.

B.3.  Example Sequence

   The client prompts the user to enter their username, and sends the
   username in an initial Authorization Challenge Request.

   POST /native-authorization HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   username=alice
   &scope=photos
   &client_id=bb16c14c73415

   The Authorization Server sends an error response indicating that an
   OTP is required.

   HTTP/1.1 401 Unauthorized
   Content-Type: application/json
   Cache-Control: no-store

   {
     "error": "otp_required",
     "auth_session": "ce6772f5e07bc8361572f"
   }

   The client prompts the user for an OTP, and sends a new Authorization
   Challenge Request.

   POST /native-authorization HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   auth_session=ce6772f5e07bc8361572f
   &otp=555121

   The Authorization Server validates the auth_session to find the
   expected user, then validates the OTP for that user, and responds
   with an authorization code.

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "authorization_code": "uY29tL2F1dGhlbnRpY"
   }

   The client sends the authorization code to the token endpoint.

   POST /token HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   grant_type=authorization_code
   &client_id=bb16c14c73415
   &code=uY29tL2F1dGhlbnRpY

   The Authorization Server responds with an access token and refresh
   token.

   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "token_type": "Bearer",
     "expires_in": 3600,
     "access_token": "d41c0692f1187fd9b326c63d",
     "refresh_token": "e090366ac1c448b8aed84cbc07"
   }

B.4.  Usage with Digital Credentials

   Digital credentials (stored in wallets) may be used by authorization
   servers to authenticate a user or approve a transaction.  This
   example flow shows how wallet credential presentation can be
   incorporated into this spec using DC API/[OpenID4VP].

User            First Party Client        AS               Wallet/DC API        Verifier
----            ------------------        ---              --------------       --------
|                     |                  |                    |                  |
|                     |                  |                    |                  |
| (1) Start Flow      |                  |                    |                  |
|-------------------->|                  |                    |                  |
|                     | (2) Native Authorization Request      |                  |
|                     |----------------->|                    |                  |
|                     | (3) Authorization Error Response      |                  |
|                     |   (insufficient_authorization,        |                  |
|                     |     dc_credential_required)           |                  |
|                     |<-----------------|                    |                  |
|                     |                  |                    |                  |
+===================== DC API branch ============================================+
|                     | (4) Presentation Request (OID4VP)     |                  |
|                     |-------------------------------------->|                  |
|                     | (5) Presentation Response (vp_token)  |                  |
|                     |<--------------------------------------|                  |
|                     | (6) vp_token                          |                  |
|                     |----------------->|                    |                  |
|                     |                  | (7) vp_token       |                  |
|                     |                  |-------------------------------------->|
|                     |                  | (8) Verification Result               |
|                     |                  |<--------------------------------------|
+================================================================================+
+=================== No DC API branch ===========================================+
|------- Same device path -------------------------------------------------------|
|                     | (9) Invoke Wallet via Deeplink        |                  |
|                     |-------------------------------------->|                  |
|                     |                  |                    | (10) Presentation Response (vp_token)
|                     |                  |                    |----------------->|
|                     |                  | (11) redirect_uri_client?handle       |
|                     |                  |<--------------------------------------|
|                     | (12) Redirect to client w/ openid4vp_redirect_uri?handle=123
|                     |<--------------------------------------|                  |
|                     | (13) Handle                           |                  |
|                     |----------------->|                    |                  |
|                     |                  | (14) Get Presentation Result          |
|                     |                  |-------------------------------------->|
|                     |                  | (15) Presentation Result              |
|                     |                  |<--------------------------------------|
|------- Cross device path ------------------------------------------------------|
| (16) Display QR Code|                  |                    |                  |
|<--------------------|                  |                    |                  |
| (17) Scan QR Code   |                  |                    |                  |
|----------------------------------------------------------->>|                  |
|                     |                  |                    | (18) Presentation Response (vp_token)
|                     |                  |                    |----------------->|
|                     +---- Loop ------------------------------------------------+
|                     | (19) Poll for authorization response                     |
|                     |----------------->|                                       |
|                     |                  | (20) Get Presentation Result          |
|                     |                  |<------------------------------------->|
|                     |                  | (21) Pending                          |
|                     |                  |<--------------------------------------|
|                     | (22) Pending     |                                       |
|                     |<-----------------|                                       |
|                     +---- Break when presentation done ------------------------|
|                     |                  | (23) Presentation Result              |
|                     |                  |<--------------------------------------|
+================================================================================+
|                     |                  |
|  Note: Assuming the happy path. In case of error, error responses are sent back accordingly.
|                     |                  |
|                     | (24) Code        |
|                     |<-----------------|
|                     | (25) Token Request w/ code
|                     |----------------->|
|                     | (26) Tokens      |
|                     |<-----------------|
|                     |                  |

   The verifier is displayed here as a separate instance, but can also
   be part of the authorization server.  In both cases, it is
   transparent to the client, as the client only talks to the
   authorization server's Native Authorization Endpoint (Section 4.1).

1.   User opens app

2.   The client indicates, as part of the Native Authorization
     Request (Section 5.1), the following:

     *  Login via digital credentials (wallet) desired

     *  DC API support

     *  Same device/cross device (only, if DC API is not supported)

     *  a redirect URI intended for redirect from a wallet to the
        client in [OpenID4VP] same device flows (hereafter called
        openid4vp_redirect_uri)

        POST /native-authorization HTTP/1.1
        Host: server.example.com
        Content-Type: application/x-www-form-urlencoded

        &client_id=bb16c14c73415
        &scope=profile
        &dc_api=false
        &login_hint=wallet
        &openid4vp_flow_type=same_device
        &openid4vp_redirect_uri=https%3A%2F%2Fdeeplink.example.client

     Note that the client may collect this information from the user
     before making the initial request, or provide what it knows
     initially and respond gradually to additional requests for
     information from the authorization server.

3.   Authorization server returns with error response
     (insufficient_authorization), indicating in the response body
     that digital credential presentation is required.  The
     authorization server's response may look like this:

HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store

{
  "error": "insufficient_authorization",
  "auth_session": "ce6772f5e07bc8361572f",
  "type": "digital_credentials_required",
  "request": "openid4vp://?request_uri=..." // omitted if the authorization server cannot yet return the presentation request
}

4.   Client invokes the DC API.

5.   The DC API returns the vp_token to the client

6.   Client sends vp_token to the authorization server

    POST /native-authorization HTTP/1.1
    Host: server.example.com
    Content-Type: application/json

    {
      "auth_session": "ce6772f5e07bc8361572f",
      "vp_token": "....."
    }

7.   The authorization server asks the verifier to verify the
     vp_token

8.   The verifier verifies the vp_token and returns the result.  The
     authorization server evaluates the verification result and
     returns either a code or an error as per Section 5.2.  Here we
     assume the happy path.  Continue with step 24.

9.   If DC API is NOT supported and in case of same device flow, the
     client invokes the Wallet through Deep Link.

10.  Wallet presents credentials to verifier.

11.  Verifier responds with a URL instructing wallet to redirect as
     per [OpenID4VP].

12.  Wallet redirects back to the client using the received URL as a
     Deep Link.

13.  Client extracts the handle from the received URL and provides it
     to the authorization server.

   POST /native-authorization HTTP/1.1
   Host: server.example.com
   Content-Type: application/json

   {
     "auth_session": "ce6772f5e07bc8361572f",
     "presentation_id" : "87248924n2f"
   }

14.  The authorization server uses the handle at verifier to look
     retrieve the presentation result.

15.  The verifier responds with the presentation result which the
     authorization server evaluates, then returns either a code or an
     error as per Section 5.2.  Here we assume the happy path.
     Continue with step 24.

16.  If DC API is NOT supported and in case of cross device, the
     client renders the presentation request as QR code and displays
     it to the user.

17.  The user scans the QR code with the wallet.

18.  The wallet presents the credentials to the verifier.

19.  Meanwhile, client polls the authorization server for the
     presentation status until it receives a non-pending result.

   POST /native-authorization HTTP/1.1
   Host: server.example.com
   Content-Type: application/json

   {
     "auth_session": "ce6772f5e07bc8361572f"
   }

20.  The authorization server in turn retreives the presentation
     status from the verifier.

21.  The verifier responds to the authorization server that the
     presentation result is not yet ready.

22.  The authorization server responds to the client that the
     presentation result is not yet ready.

   HTTP/1.1 400 Bad Request
   Content-Type: application/json
   Cache-Control: no-store

   {
     "error": "insufficient_authorization",
     "status": "pending",
     "auth_session": "ce6772f5e07bc8361572f"
   }

23.  Once the presentation is done, the verifier returns the result
     to the authorization server, which then evaluates the
     verification result and returns either a code or an error as per
     Section 5.2, breaking the loop.  Here we assume the happy path.
     Continue with step 24.

24.  The authorization server returns an authorization code to the
     client as per Section 5.2.

25.  The client redeems the code for an access token as per
     Section 6.

26.  The authorization server responds to the token request as per
     Section 6.

B.4.1.  RAR & Transaction Data

   [OpenID4VP] supports transaction data, which is additional data to be
   signed and presented alongside the requested credentials.  This can
   be mapped to RAR [RFC9396].  The following diagram depicts a wallet
   flow incorporating RAR.  Details of how the wallet is invoked or how
   the presentation result reaches the authorization server are omitted
   for simplicity.  Refer to Appendix B.4 for details.

First Party Client        AS              Wallet/DC API       Verifier
------------------        ---              --------------       --------
|                          |                    |                  |
| (1) Native Authorization Request w/ RAR       |                  |
|------------------------->|                    |                  |
|                          | (2) Create Presentation request (OIDC4VP) w/ tx_data
|                          |-------------------------------------->|
|                          | (3) Presentation request (OIDC4VP)    |
|                          |<--------------------------------------|
| (4) Presentation request (OIDC4VP)            |                  |
|<-------------------------|                    |                  |
| (5) Presentation Request (OIDC4VP)            |                  |
|---------------------------------------------->|                  |
|                          |                    | (6) Presentation Response (vp_token)
|                          |                    |----------------->|
|                          | (7) Presentation Result               |
|                          |<--------------------------------------|
| (8) code                |
|<-------------------------|
| (9) Token Request w/ code
|------------------------->|
| (10) Token Response w/ RAR
|<-------------------------|

   1.   The client initiates the OAuth request, including RAR.

   2.   The authorization server processes that RAR from the request and
        creates a transaction data object from it.  The authorization
        server then sends a request including the transaction data to
        the verifier to create a presentation request.

   3.   The verifier responds with the presentation request.

   4.   The authorization server responds to client with the
        presentation request.

   5.   The client invokes the wallet.  How exactly the wallet is
        invoked is omitted for simplicity.  See Usage with Digital
        Credentials Appendix B.4 for details.

   6.   The wallet creates a vp_token including the requested
        transaction data and sends it to the verifier.

   7.   The verifier verifies the vp_token and eventually the
        authorization server learns about the result.  How the
        authorization server learns about the result is omitted for
        simplicity.  See Usage with Digital Credentials Appendix B.4 for
        details.  The authorization server then evaluates the result,
        especially the transaction data.

   8.   The authorization server returns an authorization code to the
        client as per Section 5.2.

   9.   The client redeems the code for an access token as per
        Section 6.

   10.  The authorization server responds to the token request as per
        Section 6.  It also includes the authorization_details.

      HTTP/1.1 200 OK
      Content-Type: application/json
      Cache-Control: no-store

      {
        "access_token": "2YotnFZFEjr1zCsicMWpAA",
        "token_type": "Bearer",
        "expires_in": 3600,
        "authorization_details": [
          {
            "type": "account_information",
            "access": {
              "accounts": [
                {
                  "iban": "DE2310010010123456789"
                },
                {
                  "maskedPan": "123456xxxxxx1234"
                }
              ],
              "balances": [
                {
                  "iban": "DE2310010010123456789"
                }
              ],
              "transactions": [
                {
                  "iban": "DE2310010010123456789"
                },
                {
                  "maskedPan": "123456xxxxxx1234"
                }
              ]
            },
            "recurringIndicator": true
          }
        ]
      }

Appendix C.  Design Goals

   This specification defines a new authorization flow the client can
   use to obtain an authorization grant.  There are two primary reasons
   for designing the specification this way.

   This enables existing OAuth implementations to make fewer
   modifications to existing code by not needing to extend the token
   endpoint with new logic.  Instead, the new logic can be encapsulated
   in an entirely new endpoint, the output of which is an authorization
   code which can be redeemed for an access token at the existing token
   endpoint.

   This also mirrors more closely the existing architecture of the
   redirect-based authorization code flow.  In the authorization code
   flow, the client first initiates a request by redirecting a browser
   to the authorization endpoint, at which point the authorization
   server takes over with its own custom logic to authenticate the user
   in whatever way appropriate, possibly including interacting with
   other endpoints for the actual user authentication process.
   Afterwards, the authorization server redirects the user back to the
   client application with an authorization code in the query string.
   This specification mirrors the existing approach by having the client
   first make a POST request to the Native Authorization Endpoint, at
   which point the authorization server provides its own custom logic to
   authenticate the user, eventually returning an authorization code.

   An alternative design would be to define new custom grant types for
   the different authentication factors such as WebAuthn, OTP, etc.  The
   drawback to this design is that conceptually, these authentication
   methods do not map to an OAuth grant.  In other words, the OAuth
   authorization grant captures the user's intent to authorize access to
   some data, and that authorization is represented by an authorization
   code, not by different methods of authenticating the user.

   Another alternative option would be to have the Native Authorization
   Endpoint return an access token upon successful authentication of the
   user.  This was deliberately not chosen, as this adds a new endpoint
   that tokens would be returned from.  In most deployments, the Token
   Endpoint is the only endpoint that actually issues tokens, and
   includes all the implmentation logic around token binding, rate
   limiting, etc.  Instead of defining a new endpoint that issues tokens
   which would have to have similar logic and protections, instead the
   new endpoint only issues authorization codes, which can be exchanged
   for tokens at the existing Token Endpoint just like in the redirect-
   based Authorization Code flow.

   These design decisions should enable authorization server
   implementations to isolate and encapsulate the changes needed to
   support this specification.

Appendix D.  Document History

   -02

   *  Updated affiliations and acks

   *  Editorial clarifications

   *  Added reference to Attestation-Based Client Authentication

   -01

   *  Corrected "re-authorization of the user" to "re-authentication of
      the user"

   -00

   *  Adopted into the OAuth WG, no changes from previous individual
      draft

Acknowledgments

   The authors would like to thank the attendees of IETFs 123 & 124 in
   which this was discussed, as well as the following individuals who
   contributed ideas, feedback, and wording that shaped and formed the
   final specification: George Fletcher, Arndt Schwenkshuster, Filip
   Skokan.

Authors' Addresses

   Yaron Zehavi
   Raiffeisen Bank International
   Email: yaron.zehavi@rbinternational.com


   Aaron Parecki
   Okta
   Email: aaron@parecki.com
